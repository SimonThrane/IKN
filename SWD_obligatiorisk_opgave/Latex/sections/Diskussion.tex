\chapter{Diskussion}
Chain of reponsibility er et pattern der fokuserer meget på at fjerne koblingen mellem en klient og en modtager. På dette punkt kan man sammenligne det med Mediator Pattern \footnote{https://en.wikipedia.org/wiki/Mediator\_pattern}, hvor man uddelegerer ansvaret til en central instans som så selv finder ud hvordan en bestemt besked håndteres.
Ved Chain of responsibility kontakter en klient nemlig kun en handler, som så kan uddelegere arbejdet alt efter hvem der kan/skal håndtere forespørgslen. \\

\noindent Et sted hvor chain of responsibility konceptuelt også bliver brugt er i exceptionhandling i f.eks. C\#. Hvis en funktion kalder en anden funktion, hvor en exception opstår, og denne ikke kan håndtere exceptionen, bliver exceptionen automatisk propageret op i call stacken og lader den næste funktion forsøge at håndtere den. \\

\noindent En ulempe ved dette pattern er at setuppet omkring det med at sætte selve kæden op kan have stor risiko for fejl. En mulig fejl i forbindelse med kæde-setuppet kunne være at danne en cyklisk kæde. Kæde-setuppet ville derfor med fordel kunne lægges ud en form for Factory Method, for bl.a. at gøre designet mere testbart. En anden ulempe ved mønsteret er, at det er svært at genbruge i andre sammenhænge uden at modificere koden. \\
En fordel ved dette pattern er, at det er simpelt at forstå, og forholdsvis nemt at implementere i sin simpleste form. En fordel ved at kæde-setuppet skal oprettes i programmet er, at man kan tilpasse kæden efter programmets behov og altid sætte den handler, der forventes bliver benyttet mest bliver sat først i kæden. 
Desuden er mønstret godt i forhold til at afkoble klasser og ansvarsområder.