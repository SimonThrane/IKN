\chapter{Implementering}

Til denne opgave er der blevet implementeret et eksempel på software mønsteret chain of responsibility. I det implementerede eksempel kan der vælges mellem forskellige deserilizations-metoder. Selve implementeringen er lavet så en handler kan formatere XML og JSON format til konkrete klasser. Dette er gjort generisk, således at det er ligegyldigt hvilken type object der skal deserilizeres. 

Den overordnede abstracte klasse, som skulle styre chainen ses nedenfor

\begin{lstlisting}
public abstract class ChainHandler<T>
  {
     public ChainHandler<T> NextChain { get; set; }

     public void SetNextChain(ChainHandler<T> nextChain)
     {
         NextChain = nextChain;
     }

     public abstract T Parse(string inputdata, string inputtype);

  }
\end{lstlisting}  

I forhold til beskrivelsen ses at nextChain sættes contructoren. Som det kan ses vælges den konkrete handler på baggrund af en streng, her kaldet inputtype. Det væsentlige for de nedarvede klasser er at alle chainhandlers skal implementere metoden Parse. Metoden skal så, som beskrevet, kalde Parse på NextChain hvis den ikke selv kan håndtere kaldet.

\begin{lstlisting}
  class XMLParser<T> : ChainHandler<T>
    {
        public override T Parse(string inputdata, string inputtype)
        {
            if (inputtype.ToLower() == "xml")
            {
                Console.WriteLine("This is xml, I am parsing this");
                var serializer = new XmlSerializer(typeof(T));
                var type = (T) serializer.Deserialize(new StringReader(inputdata));
                return type;
            }
            return NextChain.Parse(inputdata, inputtype);
        }
    }
\end{lstlisting} 

Ovenfor ses et eksempel på en af handlerne. Som det kan ses nedarves den abstracte Chainhandler. Selve funktionen tjekker så på strengen inputtype om det er XML. Hvis inputtype er XML, så håndterer denne klasse kaldet, og laver objecter ud fra den streng kaldet inputdata, baseret på en antagelse om at det er XML format. Hvis ikke inputtypen er XML kaldes Parse på Nextchain. 

\begin{lstlisting}
//Setup Chain of Responsibility
            ChainHandler<Car> handler1 = new JsonParser<Car>();
            ChainHandler<Car> handler2 = new XMLParser<Car>();
            ChainHandler<Car> handler3 = new TextParser<Car>();

            handler1.SetNextChain(handler2);
            handler2.SetNextChain(handler3);
\end{lstlisting} 
   
Som det ses ovenfor sættes chainen op i programmet, hvorefter første led i kæden bliver benyttet hvis man skal være sikker på at alle led i kæden bliver travaseret. 


